今日任务
  1。mysql:看5篇文章，还要复习mybatis里是如何与mysql交互的。                                          没有搞定，要多实践，多调优。
  2.redis:复习各种数据结构，先学这个。                                                              搞定，还要多复习几遍
  3.java:继续复习八股，练习注解的使用，一定要练熟。练透
          Java里juc并发编程，学透AQS部分，可以自己写一个AQS同步器，弄清楚thread源码                  先看aqs同步器 ，看懂aqs同步器。没有看Thread的源码，按照训练营来。       
          JAVA里的设计模式，学习两个设计模式，尤其是单例模式                                        学了单例模式，工厂模式，抽象工厂模式 
          JAVA集合：搞清楚list，treeset                                                                          没有做
  4.算法：2道算法题，复习一道LRU，还要联系多线程编程，看Thread源码                                  刷了三道题，看了一道单调栈的题。
  5.操作系统：先学前边三个。                        
  6.计算机网络：没想好，先学前边三个，主要是要弄会三个网络模型，

其实今天，再来十几个小时，还是可以学完的。所以要早点休息，早点起床。

  private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus;
        if (ws < 0)
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        Node s = node.next;
        if (s == null || s.waitStatus > 0) {
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);
    }

  private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            return true;
        if (ws > 0) {
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }

  private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }

 private void setHead(Node node) {
        head = node;
        node.thread = null;
        node.prev = null;
    }
