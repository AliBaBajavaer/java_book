这辈子所有的任务清单都会写在这个文件里面。写多了就分库分表，yes！

今日任务   2024-06-26 更新于 2024-06-27/00:30
  1。mysql:看5篇文章，还要复习mybatis里是如何与mysql交互的。                                          没有搞定，要多实践，多调优。
  2.redis:复习各种数据结构，先学这个。                                                              搞定，还要多复习几遍
  3.java:继续复习八股，练习注解的使用，一定要练熟。练透                                                   完成
          Java里juc并发编程，学透AQS部分，可以自己写一个AQS同步器，弄清楚thread源码                  先看aqs同步器 ，看懂aqs同步器。没有看Thread的源码，按照训练营来。       
          JAVA里的设计模式，学习两个设计模式，尤其是单例模式                                        学了单例模式，工厂模式，抽象工厂模式 
          JAVA集合：搞清楚list，treeset                                                                          没有做
  4.算法：2道算法题，复习一道LRU，还要联系多线程编程，看Thread源码                                  刷了三道题，看了一道单调栈的题。
  5.操作系统：先学前边三个。                        
  6.计算机网络：没想好，先学前边三个，主要是要弄会三个网络模型，

其实今天，再来十几个小时，还是可以学完的。所以要早点休息，早点起床。


今日任务 
  1.mysql: 重点了锁部分的文章。继续看3~5篇文章。     今天就看五篇吧，尤其是要弄明白explain,还有mysql背后的原理，高可用这些不是我们该管的 没怎么看，看了子查询部分，复习了查询方法和explain
  2.redis: 昨天看了数据结构，今天接着看                         今天接着看一些命令，底层原理
  3.java: 并发编程看完了aqs，解这看别的。看3篇文章.   搞明白了threadlocal，map的并发编程。别的啥也没搞懂，下午再看看map,和其他容器；哦对还看了condition对象，LockSupport.HashMap源码没有太看明白，得接着看，要看明白的源码就是java集合，java并发编程。这是7月份必须完全看明白的源码
          设计模式：学习两个设计模式                            
          java基础：继续看javaguide的八股文。             学习了java数组，java集合等         
          集合：理解List集合的源码，写成文章。
          java io好好学。理解nio；           今天必须好好理解java io;完全理解透彻。今天的重点，今天算是理解了nio,bio，以及常用的bio包装类。
  4.算法：刷两道算法，复习以前的算法题         连续的子数组和  刷了两道。自己ac了两道，还有两道是抄的，其中一道太简单了；
  5.操作系统：主要要看io.这个对理解很重要。    
  6.计算机网络：                                  看看tcp/ip 一篇就行。


今日任务
  1.mysql:继续复习锁这一章节。搞清楚explain。         
  2.redis:看文章                                    看了哨兵机制，主从机制。
  3.java:
        java基础：复习知识点，                            
        jvm:虚拟机看50节课                        学习了一些
        java并发编程：接着刷题，每天都要刷题和看源码，尤其是锁       搞清楚了concrrenhashmap,linkedblockingqueue,以及一些阻塞队列。
        java集合：搞清楚hashmap,                   
  4.算法：看零茶山的一课，全部看完。刷两道题。                    刷了两道，感觉一天刷个两小时就行，睡觉吧。明天三点半起来学习。
  5.计算机网络：学习tcp/ip
总结：最近没怎么写项目，但我也觉得，没必要重复这些老项目，没一点意思，有这时间还可以多看看呢.加油陈乾珲，弟弟也不跟你说话的。晚安吧。我买了个长毛毯。看了海贼王路飞去伟大航路一集，太好看了，上次看还是12年左右吧，哈哈哈哈。我人生
最自主的一年半，二年级下学期到初三下学期。之后就是行尸走肉了。哈哈哈。好好学习呀！加油加油陈乾珲，以后就是自己和自己聊天。

  这是写下的日子，这辈子所有的任务清单都会写在这个文件里面。写多了就分库分表，yes！
今日任务：2024-06-28   刚把爹！
  java:
    java并发编程:看明白阻塞队列                 看完了阻塞队列和线程池，延时线程池和futuretask还是没有看明白。
    java集合：继续看源码：                
    java基础：慢慢看八股  
    jvm：看类加载器，这方面一天三个小时吧。也不花太多时间 毕竟东西太多了。
    java设计模式：复习一两个设计模式。
  mysql:看锁这一章。                          开始看锁。基本看完了锁，但是掌握的还不是很透彻，需要接着看。我知道了一点，那就是加锁是给扫描区间里的记录加锁。
  redis:循环看学习指引的文章。                  
  计算机网络：循环看文章，3篇                  看了tcp/ip连接。还要接着看
  操作系统：循环看文章，3篇

  我要专注于每一分钟，没必要思考以后的事情。对于我来说，过好每一个小时自然就能过好每一个月。每一年。其实我也发现了，每天还是要复习，因此以后起来的第一个任务就是复习。感觉明天可以
接着看锁这一部分。以及java的线程池框架。还有redis的数据结构部分。这十天就看redis的数据结构部分。Java基础的话。也是每天轮着来，三个小时吧。算法要多刷。多刷，多刷！jvm就按明天的来。

今日任务：

  redis: 数据结构又过一遍。                  明天可以看看redis的网络模型
  mysql：看了锁这一章，明白了加锁的流程，但是精确匹配还没搞明白，以及锁是怎么退化的
  jvm:就看训练营的那些吧，会就行了。      没有看 
  java设计模式：看一两个；               没有看，看一个吧
  java多线程编程：接着看线程池部分的。   线程池应该说阻塞队列这块不行，还有futuretask这块也不行，得多看几遍。看看阻塞队列吧
  算法：刷了几道简单的滑动窗口。明天接着刷滑动窗口。还要听一听灵神是怎么做的。

    线程池：
            为什么线程池的线程不会回收，很简单，线城池的线程是worker对象，他的run方法是死循环，永远不会回收。除非关闭线程池。
            线程池包括一个list对象存放线程，一个阻塞队列存放任务。因此线程池应该有一个主方法。用来进行判断。阻塞队列里的元素类型必须为runnable,或者Callable,后者相比前者可以返回
            线程的结果。
            线程池的参数：
                          1.核心线程数
                          2.最大线程数，阻塞队列，存活时间，时间单位，拒绝策略。这一切都围绕着线程池的处理流程来展开
            核心流程：当任务被提交时，是通过线程池的execute方法提交的。而不是直接放到阻塞队列里。如果线程池里的线程数并不到核心线程数，那就创建一个线程来处理他。如果达到了。
                      就放到阻塞队列里。如果阻塞队列满了，在线程数没有达到最大线程数的情况下,创建一个线程来执行他。该线程在存活一定时间后会被销毁。如果线程数达到最大线程数。
                      那么任务就会被丢弃。
            提交任务的方法：execute（runnable）,此时没有返回结果，而submit（callable）是有返回结果的。
            关闭线程池：    shutdown,shutdownNow,他们都是调用interrupt方法中断线程，区别在于，shutdown只会中断没有运行的线程。
            查看线程池是否终止：isTerminated();
            线程执行结果的获取：Future或者FutureTask对象来获取执行结果，通过object.get()方法来获取。后者可以对线程进行操控。这里的线程池采用的是JAVA传统的线程方式。
            FutureTask可以用来协调各个线程的工作.
            根据线程池的参数不同，会分为很多不同的线程池。关键在于阻塞队列的选择，拒绝策略，此外可以对线程池进行继承，实现自己的线程池。达到不同的效果。比如延时线程池。固定线程池
          不同的线程池，并发效果是不一样的。比如cachethreadpool的并发能力最大。因为它可以创建无数的线程。
              线程池中线程的个数根据任务类型，cpu数量来定，io密集型应该使用2*Ncpu;cpu密集型应该采用Ncpu+1来做。
            java本身提供了四种线程池，前三种根据线程池线程数量区分，最后一种可以执行延时任务。
  线程池的创建采用了Execute框架。

今日任务：  从今天开始都要写记录。
    mysql:接着看文章，看两三篇吧，看一看mysql的逻辑架构，和引擎；redolog,undolog,          看了redolog,undolog，binlog
    redis:看网络模型那一章，                                                               复习了持久化
    java并发编程：好像都看完了。得复习一下，拔高以下，看看应用                             又看了看线程池，更理解了但是没有看futuretask
    java设计模式：每天两个设计模式                                                        以后每天起来先看设计模式
    java基础：接着看java基础                                                              没有看
    jvm：学习                                                                            学习了类加载机制，双亲委派机制等
    算法：刷双指针，每天刷一些sql题。                                                      刷了两三道滑动窗口的题。
    计算机网络：看tcp/ip一节                                                               看了tcp/ip的拥塞，滑动窗口，以及rpc协议，websocket格式
    操作系统：看小林coding                    没咋看。

    mysql加锁：mysql无论是什么语句，在确定了扫描区间后就会进行加锁。正常的枷锁流程就是确定扫描区间然后逐个加next-key锁。但在一些情况下锁会退化。我们要注意这些特殊情况。
    redis持久化：redis的持久化通过aof,rdb来实现。在这其中要注意写时复制技术。是实现高性能持久化的基础。
    java并发编程：难点在于能不能自己手写一个高效的线程池，应对不同的并发请求。只要涉及到生产者消费者模式的。都可以使用ree锁，其他就用syn锁。书写简单。
    mysql日志：  怎么理解Undo，redo，里面存的是数据，所以其实就是数据页的备份，只不过redolog寸的是多个版本的数据的备份，redolog和undo寸的都是和事务相关的数据。rollback时把undolog拿出来刷盘，恢复时把redolog拿出来刷盘。那怎么主从复制呢，用Binlog，事务是否提交以binlog为主，怎么判断事务是否需要恢复，
  就是看binlog和redolog里的事务id，事务id可以在Binlog里面找到，就恢复，找不到就去undolog里进行回滚。
  ·  一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：

          通过 trx_id 可以知道该记录是被哪个事务修改的；
          通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；
    那么undolog如何持久化，undolog本身也是数据页，undolog通过redolog持久化。
  什么是redolog？
    redo log 是物理日志，记录了某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新，每当执行一个事务就会产生这样的一条或者多条物理日志。在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。
    当事务提交的时候redoLog一定会刷盘的。事务提交时binlog也会刷盘的。redolog可以实现顺序磁盘写。这一点比随机Io效率要高得多。此外redolog也会有其他的刷盘措施。
  
  我觉得我应该做做项目了。基本都看明白了。以后要猛攻网络，网络是架构的基础。





我感觉主要是白天的运动量太小了。然后天天看短视频，其实我很早就开始睡不着了，主要是独居引起的精神兴奋。然后其实我白天并没有很充实的过着。因为我起的太晚了。就是这样，寒假在家我也睡得很好。长期睡不着就会导致昼夜颠倒。嗯嗯，也不是加油，我觉得我需要做出抉择。技术大咖还是混混。只会扣手机的人
我陈乾珲，于2024年7月三日凌晨1点27分宣布，从今开始不再看贴吧，海贼王，哔哩哔哩，只刷算法，看小林，学Java，跑步，睡觉。除此以外什么也不干。有时候就听听音乐。作为消遣，对我也不看什么房子，什么都不看。只看java，戒掉短视频。




今日任务： 2024-07-03
  java：复习了几种设计模式，学习jvm：待会吃完饭回来学。
  计算机网络：要写文章才行，每天看完要理解一下，这个估计得一个月。慢慢看吧，每天主要看tcp/ip；我们还要看看协议怎么拟定。
  java并发编程：看了cas原子类。以及并发编程常用工具。
  mysql：
      1.看buffer pool 
      mysql的buffer pool用三种链表来管理buffer pool的内存空间。通过后台线程定期的刷新脏页。通过redolog来保证数据宕机也可以恢复。以及mysql的lru算法的实现。
      buffer pool 的内存大小是128mb,可以通过参数调节。
      2.看一看mysql运行时的内存结构，搞明白各个分区都是干什么的。相比于其他技术，mysql是目前进展最好的。要继续努力！
      3.mysql的行记录模式，搞清楚是怎么存储的，一行的最大能占用多少字节。溢出列怎么处理。
      4.看一看buffer pool里的change buffer
        写操作时，如果更新页不在内存里，会将数据写在change buffer里，然后定期的merge，异步的写入到磁盘里，当然，如果访问了数据所在页，也会自动触发merge。处理读大于写的任务时，普通索引加上change buffer可以很好的满足大量
  写入的要求。
      5.select的执行流程
          连接器（连接池，每一个连接都对应一个线程）   解析器（语法，词法解析），优化器（建立执行计划），执行器（与执行引擎交互，单位是记录。执行引擎根据扫描区间拿到记录后返回给执行器，执行器判断是否符合查询条件。如果查询条件就是索引，那么判断会直接在引擎层执行。） 执行引擎
      6.mysql内存结构，看一看吧。
      7.看懂了两阶段提交，和order by的优化方式。
感悟：这些唯一两个狠抓的就是mysql和redis，每天循环的看，好好看！今天mysql没什么长进，我觉得可以一遍遍看吧。


    
今日任务：
    mysql：继续杂七杂八的看，但我觉得还是应该接着搞懂mysql的逻辑结构，再看看B+树。 目前看了为什么存储不能超过2000w,因为层高三层较为合适。四层会有磁盘Io。看了B+树的储存。我觉得我可以看看别的，总结一下sql语句的执行流程。主要就是各个sql语句的执行流程。
          一个知识点就是Mysql的各个查询都是怎么工作的。
                  select ,order by ,group by,distinct,union,子查询，join这几个的流程，会采用什么算法，怎么优化。
            order by 记住filesort_buffer，
            join: nlj,bnl，bka,hash join四种方式，Bka本质上优化的是回表以及对驱动表的扫描次数。被驱动表根据索引获得的id是随机的。那么就可以使用bka，mrr对id进行排序，这样就可以优化了。因此Join查询最好就是bka,其次是inlj，bnl，最差是snlj，记住选择小表作为驱动表。
                  inlj：前提是查询被驱动表用到了索引。那么流程：
                              1.扫描驱动表的记录，获得符合查询条件的记录，
                              2.根据被驱动表的索引来查询。获得被驱动的主键id，回表查询得到记录
                              3.判断记录是否符合要求，符合就组成结果集。返回一条。
                  缺点：访问被驱动表的时候是随机io。
                        假设驱动表记录是100次，那么被驱动表也会被扫描100次。扫描次数是200次。
                  snlj：被驱动表没有索引，那么就会触发被驱动表的全表扫描。过程和inlj一样
                  缺点：假设被驱动表记录100次，被驱动表记录数是10000次，那么扫描次数是100+100*10000次；
                  BNL：使用Join buffer,将驱动表加载进内存里，然后把被驱动表加载进内存里，从被驱动表里取出一条记录。与内存里的驱动表进行比对；
                        假设驱动表内存记录数是100行，被驱动表10000行，那么扫描次数就是100+10000，但是判断次数是100*10000，很占用cpu资源。
                        此外，如果join_buffer撑不下驱动表，被驱动表就要被多次扫描。扫描次数是N+λ*N*M;判断次数仍然是N*M，即100*10000；
                  bak:  bak其实就是snlj，但是bak的前提是访问被驱动表的时候用到了索引。 对于inlj的随机io问题，bak算法会将查询索引得到的被驱动表id值放在mrr里，进行排序，然后顺序Io。
                        1.将驱动表的记录加载进join_buffer,将join_buffer里的记录与被驱动表的索引进行匹配。得到一系列的被驱动表id，
                        2.将被驱动表id放到mrr缓存里。mrr对id进行排序，之后顺序回表，返回结果集。
                  bak算法即优化了inlj的随机io,而且用到了join_buffer，减少了对驱动表的io次数。效果是最好的。假设驱动表有100行，被驱动表扫描后有100行，那么扫描次数就是100+100，而且是顺序io，批量io。有助于增加join语句的执行速率
                        bak缺点：如果被驱动表加大。那么就要维护一个很大的索引树，为了优化。可以创立临时表。对临时表加索引。这样更可以优化了。
                  hash join: 将连接表与被驱动表的记录拿到java里，使用hashmap作为中间点。进行组合。
                  
            group by :
                  1.根据group by的依据，构建临时表。将select里的数据挑出来作为临时表的字段，临时表的主键就是group by的依据
                  2.全部拿出来后，再放到sort_buffer里进行排序。执行聚合函数。返回结果集。
                  怎么优化group by:可以省掉排序，去重的步骤，那就是给group by 创建索引。直接扫描索引就行了。还不用回表。
      
            distinct:
                    1.将distinct字段拿出来作为主键。放到临时表里面，之后sort_buffer里去重。
            union:
                  1.将第一个子查询的全部字段作为主键，
                  2.创建临时表，执行union后的子查询时，在将查询结果放到临时表前，先要判断是否有主键冲突，如果有就会舍弃该条结果。
                  3.查询完毕后，将临时表作为结果集，返回，并删除临时表
            union all :
                  相比于union不会创建临时表，会直接返回每一个子查询的记录。
            
            子查询：
                    
        redis:
            多线程网络模型看的不咋地，得多看几遍。看了过期删除策略和内存淘汰策略。
            看一看二进制协议，看了redis的resp协议，之后再看多线程模型吧，得一遍一遍看，
            我感觉,redis和mysql一天各自最少三小时。
            redis:   
                      缓存，缓存属于临界资源，要修改缓存的话，必须使用分布式锁。而使用分布式锁，就要考虑到多节点的问题，npc问题
                      怎么分片，哈希槽以及缓存一致性问题。
        redis:感觉实操不行，找个时间实操一波。加深印象。
        java设计模式：
              备忘录模式：用于恢复发起人的状态。可以恢复任意时刻的状态。
                  源发器（Originator）：需要保存和恢复状态的对象。它创建一个备忘录对象，用于存储当前对象的状态，也可以使用备忘录对象恢复自身的状态。
                  备忘录（Memento）：存储源发器对象的状态。备忘录对象可以包括一个或多个状态属性，源发器可以根据需要保存和恢复状态。
                  管理者（Caretaker）：负责保存备忘录对象，但不能修改备忘录对象的内容。它可以存储多个备忘录对象，并决定何时将备忘录恢复给源发器。

               访问者模式：
  
         java并发编程：
                  多线程要多看。

            以后每天早上四点起来，看mysql+redis看到11点，之后干别的事情。这俩太重要了.


      今日任务 2024/07/05
          mysql：
            看explain查询计划。分库分表，数据库连接池，别的好像没看
          redis:感觉可以看看高可用部分。然后自己我觉得也没必要非得写个项目，写项目太花时间了，看了集群。这部分挺难理解的。可以实操一下；
          并发编程：aqs
          总结：以后每天都要看这三个，这三个是重点中的重点。
          java设计模式：复习java的设计模式，
          java:背java的八股文了，每天三四个小时。这样两点前解决这四个。
          算法：刷了单调栈，感觉不能贪多。慢慢刷吧.我觉得每天看看灵神的视频是耗时最少的了。不要看多，没用
          
          
          今日任务：2024/07/06
        java：
                明确以后就是上午数据库+并发编程，下午Java+jvm，晚上计算机网络+算法+操作系统
                学完序列化，反射，注解三大块。学习Jvm里的字节码部分

        jdk内置的序列化时两个流。
              jdk序列化的时候不会序列化静态变量，trasient变量，只会序列化成员变量。注意也不会序列化方法这些。
              jdk序列化的时候包括两部分，头部，对象，头部生命版本号，魔数，对象部写成员属性。还包括开始结束符，类名，签名，属性，属性值。
              以及一些特殊分隔符。
            序列化Id:
    如果可序列化类没有显式声明 serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认
    serialVersionUID 值。尽管这样，还是建议在每一个序列化的类中显式指定 serialVersionUID 的值。
    因为不同的 jdk 编译很可能会生成不同的 serialVersionUID 默认值，从而导致在反序列化时抛出 InvalidClassExceptions 异常。
    serialVersionUID 字段必须是 static final long 类型。
            序列化要点：
            1.父类如果是se,子类就都可以序列化。而子类是，父类不是，父类不会被序列化，数据丢失
            2.属性是对象类型，属性必须实现序列化，否则会报错
            3.反序列化时，如果对象属性有修改，增加，删减，那么修改部分数据丢失，不会报错
            4.反序列化时Id被修改会序列化失败。
            5.序列化会忽略trasient的属性
      java还指定了Externalizable接口实现自定义的序列化，但他的协议依然是Jdk自身的协议，jdk序列化是无法跨语言，且非常的笨重，不适合在网络中
进行传输。因此应该使用二进制序列化，以及json序列化。对于http应用，使用json序列化，对于微服务相互调用就应该使用二进制序列化，当我们进行传输的时候
      首先应该考虑的就是序列化的协议。一般基于某种编码的字符串是最合适的
      json序列化：  可以用FastJson,Jackson,Gson来进行json序列化，spring默认Jackson进行序列化。从性能上看Fastjson > Jackson > Gson

  序列化要考虑到 安全性（是否存在漏洞，加密。当然使用https时网络报文层面会进行加密，但自定义的rpc是没有加密的），兼容性（跨平台，跨语言），性能（时间，空间），易用性。
    java反射：
        反射广泛应用于注解，框架，动态代理里面。
        反射首先要获取Class文件，class文件的获取方式有四种，常用的是三种，第四种不会对Class对象进行初始化。Class文件本质是Class对象
    通过CLass文件可以获取Method,FIELD对象。通过Method,field对象可以获取Annotation对象，之后可以获取注解的值，进行赋值操作。对私有的成员，方法进行调用时
首先要修改可达性，修改为true;
      反射的缺点：存在安全性问题，反射的性能稍差。
      反射可以去修改成员属性的值，调用成员方法，生成对象。  
      反射的本质就是将JAVA类里的各种成分都映射成为对象，method映射成Method对象，成员就映射成FIELD对象。
      instanceof 关键字比较的就是class对象是否一致。
      动态代理：
      jdk自带的：        实现InvocationHandler的接口必须是代理模式，里面有原目标对象的属性，之后重写invoke方法。然后调用Proxy.newInstance()方法创建代理对象。这样创建的class对象，在使用结束后就会被销毁，减轻内存的负担，但是动态代理只能基于接口进行，对于一些类对象，想实现动态代理只能用cglib动态代理
      cglib:   spring里的aop使用cglib来生成动态对象。代码上和jdk差别不大，但是底层逻辑不一样。在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用
注解：
    定义注解时要用到元注解
    @Documented
    @Target({ElementType.FIELD, ElementType.PARAMETER})   //可以出现在属性，参数上
    @Retention(RetentionPolicy.RUNTIME)                   //可以出现在运行时。即可以通过反射获取他。
    public @interface RegexValid {}
注解属性只能使用 public 或默认访问级别（即不指定访问级别修饰符）修饰。

注解属性的数据类型有限制要求。支持的数据类型如下：

所有基本数据类型（byte、char、short、int、long、float、double、boolean）
String 类型
Class 类
enum 类型
Annotation 类型
以上所有类型的数组
注解属性必须有确定的值，建议指定默认值。注解属性只能通过指定默认值或使用注解时指定属性值，相较之下，指定默认值的方式更为可靠。注解属性如果是引用类型，不可以为 null。这个约束使得注解处理器很难判断注解属性是默认值，或是使用注解时所指定的属性值。为此，我们设置默认值时，一般会定义一些特殊的值，例如空字符串或者负数。

如果注解中只有一个属性值，最好将其命名为 value。因为，指定属性名为 value，在使用注解时，指定 value 的值可以不指定属性名称。
使用注解：
      Method,Field属性都有isAnnotationPresent,和getAnnotation(Class class)属性来获取方法，属性，参数上的注解。进而获取值。
枚举：
          在 enum 中，提供了一些基本方法：

          values()：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。
          name()：返回实例名。
          ordinal()：返回实例声明时的次序，从 0 开始。
          getDeclaringClass()：返回实例所属的 enum 类型。
          equals() ：判断是否为同一个对象。
          可以使用 == 来比较enum实例。

          此外，java.lang.Enum实现了Comparable和 Serializable 接口，所以也提供 compareTo() 方法。

          枚举也可以实现方法，枚举自身也可以定义方法。也可以调用方法。
          枚举适合实现单例模式。而且是最佳方法。
  netty：
        使用Channel，ByteBuffer读取磁盘文件.
       try(FileChannel channel=new FileInputStream("E:\\project0\\Redis-笔记资料\\03-高级篇\\资料\\juc_learn\\juc1\\eslearn\\src\\test\\resources\\application.yaml").getChannel()) {
            ByteBuffer buffer = ByteBuffer.allocate(10);
           while(channel.read(buffer)!=-1)//read代表的是方向，从磁盘到内存，write代表的是从内存写到磁盘。
           {
               buffer.flip();//切换到buffer的读模式
               while (buffer.hasRemaining())
               {
                   byte b = buffer.get();
                   System.out.print((char)b);
               }
               buffer.clear();//清空buffer，切换为写模式
           }
          Channel是FileInputStream读写文件的关键。ByteBuffer是内存里的区域，用来存储Channel读写的字节。
  mysql:
        子查询执行流程。以及一条普通sql语句的执行流程
  感觉并发编程得一遍一遍地看，一遍一遍的做，刷题。现在首先学会各个api的使用，把leetcode的十道题全部刷完。然后多多看源码，写总结。但我感觉，网络Io加上多线程才是网络编程。redis我觉得明天可以看看Lua,学会搭建redis集群
  mysql的话，我感觉要一遍一遍的看。现在重点看看事务机制。


