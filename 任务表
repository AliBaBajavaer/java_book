这辈子所有的任务清单都会写在这个文件里面。写多了就分库分表，yes！

今日任务   2024-06-26 更新于 2024-06-27/00:30
  1。mysql:看5篇文章，还要复习mybatis里是如何与mysql交互的。                                          没有搞定，要多实践，多调优。
  2.redis:复习各种数据结构，先学这个。                                                              搞定，还要多复习几遍
  3.java:继续复习八股，练习注解的使用，一定要练熟。练透                                                   完成
          Java里juc并发编程，学透AQS部分，可以自己写一个AQS同步器，弄清楚thread源码                  先看aqs同步器 ，看懂aqs同步器。没有看Thread的源码，按照训练营来。       
          JAVA里的设计模式，学习两个设计模式，尤其是单例模式                                        学了单例模式，工厂模式，抽象工厂模式 
          JAVA集合：搞清楚list，treeset                                                                          没有做
  4.算法：2道算法题，复习一道LRU，还要联系多线程编程，看Thread源码                                  刷了三道题，看了一道单调栈的题。
  5.操作系统：先学前边三个。                        
  6.计算机网络：没想好，先学前边三个，主要是要弄会三个网络模型，

其实今天，再来十几个小时，还是可以学完的。所以要早点休息，早点起床。


今日任务 
  1.mysql: 重点了锁部分的文章。继续看3~5篇文章。     今天就看五篇吧，尤其是要弄明白explain,还有mysql背后的原理，高可用这些不是我们该管的 没怎么看，看了子查询部分，复习了查询方法和explain
  2.redis: 昨天看了数据结构，今天接着看                         今天接着看一些命令，底层原理
  3.java: 并发编程看完了aqs，解这看别的。看3篇文章.   搞明白了threadlocal，map的并发编程。别的啥也没搞懂，下午再看看map,和其他容器；哦对还看了condition对象，LockSupport.HashMap源码没有太看明白，得接着看，要看明白的源码就是java集合，java并发编程。这是7月份必须完全看明白的源码
          设计模式：学习两个设计模式                            
          java基础：继续看javaguide的八股文。             学习了java数组，java集合等         
          集合：理解List集合的源码，写成文章。
          java io好好学。理解nio；           今天必须好好理解java io;完全理解透彻。今天的重点，今天算是理解了nio,bio，以及常用的bio包装类。
  4.算法：刷两道算法，复习以前的算法题         连续的子数组和  刷了两道。自己ac了两道，还有两道是抄的，其中一道太简单了；
  5.操作系统：主要要看io.这个对理解很重要。    
  6.计算机网络：                                  看看tcp/ip 一篇就行。


今日任务
  1.mysql:继续复习锁这一章节。搞清楚explain。         
  2.redis:看文章                                    看了哨兵机制，主从机制。
  3.java:
        java基础：复习知识点，                            
        jvm:虚拟机看50节课                        学习了一些
        java并发编程：接着刷题，每天都要刷题和看源码，尤其是锁       搞清楚了concrrenhashmap,linkedblockingqueue,以及一些阻塞队列。
        java集合：搞清楚hashmap,                   
  4.算法：看零茶山的一课，全部看完。刷两道题。                    刷了两道，感觉一天刷个两小时就行，睡觉吧。明天三点半起来学习。
  5.计算机网络：学习tcp/ip
总结：最近没怎么写项目，但我也觉得，没必要重复这些老项目，没一点意思，有这时间还可以多看看呢.加油陈乾珲，弟弟也不跟你说话的。晚安吧。我买了个长毛毯。看了海贼王路飞去伟大航路一集，太好看了，上次看还是12年左右吧，哈哈哈哈。我人生
最自主的一年半，二年级下学期到初三下学期。之后就是行尸走肉了。哈哈哈。好好学习呀！加油加油陈乾珲，以后就是自己和自己聊天。

  这是写下的日子，这辈子所有的任务清单都会写在这个文件里面。写多了就分库分表，yes！
今日任务：2024-06-28   刚把爹！
  java:
    java并发编程:看明白阻塞队列                 看完了阻塞队列和线程池，延时线程池和futuretask还是没有看明白。
    java集合：继续看源码：                
    java基础：慢慢看八股  
    jvm：看类加载器，这方面一天三个小时吧。也不花太多时间 毕竟东西太多了。
    java设计模式：复习一两个设计模式。
  mysql:看锁这一章。                          开始看锁。基本看完了锁，但是掌握的还不是很透彻，需要接着看。我知道了一点，那就是加锁是给扫描区间里的记录加锁。
  redis:循环看学习指引的文章。                  
  计算机网络：循环看文章，3篇                  看了tcp/ip连接。还要接着看
  操作系统：循环看文章，3篇

  我要专注于每一分钟，没必要思考以后的事情。对于我来说，过好每一个小时自然就能过好每一个月。每一年。其实我也发现了，每天还是要复习，因此以后起来的第一个任务就是复习。感觉明天可以
接着看锁这一部分。以及java的线程池框架。还有redis的数据结构部分。这十天就看redis的数据结构部分。Java基础的话。也是每天轮着来，三个小时吧。算法要多刷。多刷，多刷！jvm就按明天的来。

今日任务：

  redis: 数据结构又过一遍。                  明天可以看看redis的网络模型
  mysql：看了锁这一章，明白了加锁的流程，但是精确匹配还没搞明白，以及锁是怎么退化的
  jvm:就看训练营的那些吧，会就行了。      没有看 
  java设计模式：看一两个；               没有看，看一个吧
  java多线程编程：接着看线程池部分的。   线程池应该说阻塞队列这块不行，还有futuretask这块也不行，得多看几遍。看看阻塞队列吧
  算法：刷了几道简单的滑动窗口。明天接着刷滑动窗口。还要听一听灵神是怎么做的。

    线程池：
            为什么线程池的线程不会回收，很简单，线城池的线程是worker对象，他的run方法是死循环，永远不会回收。除非关闭线程池。
            线程池包括一个list对象存放线程，一个阻塞队列存放任务。因此线程池应该有一个主方法。用来进行判断。阻塞队列里的元素类型必须为runnable,或者Callable,后者相比前者可以返回
            线程的结果。
            线程池的参数：
                          1.核心线程数
                          2.最大线程数，阻塞队列，存活时间，时间单位，拒绝策略。这一切都围绕着线程池的处理流程来展开
            核心流程：当任务被提交时，是通过线程池的execute方法提交的。而不是直接放到阻塞队列里。如果线程池里的线程数并不到核心线程数，那就创建一个线程来处理他。如果达到了。
                      就放到阻塞队列里。如果阻塞队列满了，在线程数没有达到最大线程数的情况下,创建一个线程来执行他。该线程在存活一定时间后会被销毁。如果线程数达到最大线程数。
                      那么任务就会被丢弃。
            提交任务的方法：execute（runnable）,此时没有返回结果，而submit（callable）是有返回结果的。
            关闭线程池：    shutdown,shutdownNow,他们都是调用interrupt方法中断线程，区别在于，shutdown只会中断没有运行的线程。
            查看线程池是否终止：isTerminated();
            线程执行结果的获取：Future或者FutureTask对象来获取执行结果，通过object.get()方法来获取。后者可以对线程进行操控。这里的线程池采用的是JAVA传统的线程方式。
            FutureTask可以用来协调各个线程的工作.
            根据线程池的参数不同，会分为很多不同的线程池。关键在于阻塞队列的选择，拒绝策略，此外可以对线程池进行继承，实现自己的线程池。达到不同的效果。比如延时线程池。固定线程池
          不同的线程池，并发效果是不一样的。比如cachethreadpool的并发能力最大。因为它可以创建无数的线程。
              线程池中线程的个数根据任务类型，cpu数量来定，io密集型应该使用2*Ncpu;cpu密集型应该采用Ncpu+1来做。
            java本身提供了四种线程池，前三种根据线程池线程数量区分，最后一种可以执行延时任务。
  线程池的创建采用了Execute框架。

今日任务：  从今天开始都要写记录。
    mysql:接着看文章，看两三篇吧，看一看mysql的逻辑架构，和引擎；redolog,undolog,          看了redolog,undolog，binlog
    redis:看网络模型那一章，                                                               复习了持久化
    java并发编程：好像都看完了。得复习一下，拔高以下，看看应用                             又看了看线程池，更理解了但是没有看futuretask
    java设计模式：每天两个设计模式                                                        以后每天起来先看设计模式
    java基础：接着看java基础                                                              没有看
    jvm：学习                                                                            学习了类加载机制，双亲委派机制等
    算法：刷双指针，每天刷一些sql题。                                                      刷了两三道滑动窗口的题。
    计算机网络：看tcp/ip一节                                                               看了tcp/ip的拥塞，滑动窗口，以及rpc协议，websocket格式
    操作系统：看小林coding                    没咋看。

    mysql加锁：mysql无论是什么语句，在确定了扫描区间后就会进行加锁。正常的枷锁流程就是确定扫描区间然后逐个加next-key锁。但在一些情况下锁会退化。我们要注意这些特殊情况。
    redis持久化：redis的持久化通过aof,rdb来实现。在这其中要注意写时复制技术。是实现高性能持久化的基础。
    java并发编程：难点在于能不能自己手写一个高效的线程池，应对不同的并发请求。只要涉及到生产者消费者模式的。都可以使用ree锁，其他就用syn锁。书写简单。
    mysql日志：  怎么理解Undo，redo，里面存的是数据，所以其实就是数据页的备份，只不过redolog寸的是多个版本的数据的备份，redolog和undo寸的都是和事务相关的数据。rollback时把undolog拿出来刷盘，恢复时把redolog拿出来刷盘。那怎么主从复制呢，用Binlog，事务是否提交以binlog为主，怎么判断事务是否需要恢复，
  就是看binlog和redolog里的事务id，事务id可以在Binlog里面找到，就恢复，找不到就去undolog里进行回滚。
  ·  一条记录的每一次更新操作产生的 undo log 格式都有一个 roll_pointer 指针和一个 trx_id 事务id：

          通过 trx_id 可以知道该记录是被哪个事务修改的；
          通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；
    那么undolog如何持久化，undolog本身也是数据页，undolog通过redolog持久化。
  什么是redolog？
    redo log 是物理日志，记录了某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新，每当执行一个事务就会产生这样的一条或者多条物理日志。在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。
    当事务提交的时候redoLog一定会刷盘的。事务提交时binlog也会刷盘的。redolog可以实现顺序磁盘写。这一点比随机Io效率要高得多。此外redolog也会有其他的刷盘措施。
  

















