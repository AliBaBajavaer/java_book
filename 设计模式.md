装饰模式相比于代理模式，多了一层继承和实现，代理模式只有三个角色。装饰模式还可以继承代理类，将代理类作为被装饰的对象。所以装饰模式应该将抽象装饰构建定义成接口。因此如果要实现的功能更多，应该考虑装饰模式。只是我们要分清那个是抽象构件，具体构件。本质上具体构件已经可以调用了。抽象装饰构件里包含了具体构件。然后具体构件可以一层一层的套用。实现复杂的功能。
    装饰模式：
          抽象构件
          具体构件
          抽象装饰
          具体装饰
    具体装饰可以进一步将具体装饰当作装饰构件。
代理模式：
        抽象接口
        具体实现类：
        代理类：
      代理模式和装饰者有点像。但其实装饰着模式就是代理模式的加强版本。
适配器模式：
        原目标接口
        现有类
        适配器类：  适配器类同时包含两个接口，在原目标接口的方法里调用现有类的方法。实现解耦合。满足不同的需要只需要写不同的适配器类即可。
外观模式：
      外观：总的接口，比如点餐按钮等。
      子系统：子系统有多个。分开写。方便今后的代码改动。
  外观模式用来处理一系列复杂的流程。将他们封装给不同的对象，对外暴露一致的接口。提高的代码的复用性和灵活性。
桥接模式：
      抽象类+接口，可以提供两个维度的变化。提高代码的灵活性。
      抽象部分（Abstraction）：定义了抽象部分的接口，并包含对实现部分的引用。
实现部分（Implementor）：定义了实现部分的接口。
具体抽象（Concrete Abstraction）：继承抽象部分，实现其中定义的抽象方法。
具体实现（Concrete Implementor）：实现Implementor，实现其中定义的具体行为。
  桥接模式和抽象工厂方式是类似的。但桥接模式提供的是对外的方法，抽象工厂模式对外提供的是对象。
组合模式：
    是一种树型组织的模式。

享元模式：
    抽象元素：
    具体元素：
    享元工厂：
      对于方法里反复出现和创建的对象，采用享元模式的方式，缓存到内存里。其实也就是线程池了。唯一可以被缓存的对象就是线程，连接。
面向对象相比于面向过程的好处就是提高代码的复用性。将过程封装给一个个的对象。提高复用性。

命令模式：
      执行模块之间通过命令对象进行沟通。
  抽象命令（Command）：命令是一个抽象接口，定义了执行操作的统一方法。具体的命令类会实现这个接口，并提供执行相应操作的具体逻辑。
  具体命令（Concrete Command）：具体命令类实现了抽象命令，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。
  接收者（Receiver）：执行实际命令的类，命令对象会调用接收者的方法来执行请求。
  调用者（Invoker）：持有命令对象，通常是多个，并通过访问命令对象来执行相关请求，他不直接访问接收者。


状态模式：执行完后自动切换状态对象。很妙。
    上下文（Context）：定义客户端需要的接口，并且负责具体状态的切换。
    抽象状态（Abstract State）：抽象状态类是所有具体状态类的基类或接口。负责定义该状态下的行为，可以一个或多个。
    具体状态（Concrete State）：具体状态类实现了抽象状态类定义的接口，并根据当前状态决定上下文对象的行为。

观察者模式：
    抽象被观察者（Subject）：定义了一个接口，包含了注册观察者、删除观察者、通知观察者等方法。
    具体被观察者（ConcreteSubject）：实现了抽象被观察者接口，维护了一个观察者列表，并在状态发生改变时通知所有注册的观察者。
    抽象观察者（Observer）：定义了一个接口，包含了更新状态的方法。
    具体观察者（ConcreteObserver）：实现了抽象观察者接口，存储了需要观察的被观察者对象，并在被观察者状态发生改变时进行相应的处理。


中介者模式
  抽象中介者（Mediator）：用于协调各个同事对象之间交互的通用接口，如接收和发送消息等。
  具体中介者（Concrete Mediator）：实现抽象中介者接口，定义一个List来管理同时对象，协调各个同事对象之间的交互，依赖于同事角色。
  抽象同事类（Colleague）：保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。
  具体同事类（Concrete Colleague）：实现抽象同事类接口，当需要与其他同事对象交互时，由中介者对象负责后续的交互，简单地说就是维护和中介者对象的通信


