mysql查询最大连接数：

​	show variables like '%max_connections%'

可以看到，一个mysql服务器只能同时承受151个连接，最大连接数指的是能同时与mysql数据库建立连接的客户数量，对于每个连接，都要分配一定的内存空间，语句缓存，大量连接会影响数据库的性能，导致内存不足。

​	![image-20240624201517864](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240624201517864.png)

```
MySQL的连接数指的是同时连接到数据库服务器的客户端数量。当有大量的用户或应用程序同时访问数据库时，这些连接数会直接影响服务器的性能和资源使用情况。MySQL通过配置文件（my.cnf 或者在Windows上是my.ini）中的max_connections参数来设定最大并发连接数。

max_connections：这是MySQL服务器能够接受的最大同时连接数。超过这个值，新的连接请求将被拒绝，除非有旧连接断开。
wait_timeout：如果一个连接长时间没有活动，MySQL会自动断开这样的连接，避免资源浪费。
innodb_thread_concurrency: 对InnoDB引擎来说，这个参数控制了并发事务的数量，而不是总连接数。
```

单机数据库的存储容量和连接数都是有限的，表的数据量在百万内时，可以采用索引，从库来优化性能，但是当数据量达到千万时，就需要用到分表技术。一个数据库只能使用100多个连接，因此单击数据库无法满足高并发要求。常用措施是垂直分库水平分表。

分表的好处：

​	大表会带来查询性能下降，锁竞争激烈，增删改语句性能降低，备份恢复时间变长的坏处。一般超过500W行或者数据量超过2GB时就要分表。

​	分表：垂直分表，水平分表。

​	水平分表的依据：hash取模

​	垂直分表：冷热数据分离，将原表分为主表和扩展表。拆表后，如果出现大量的连表查询，就说明拆分不合理。

分库：

​	高并发场景下，由于数据库本身的连接是一定的。过多的并发降低服务的性能。因此要进行分库，转库专用，提供更多的数据库连接。提升系统的并发度。

​	分库：垂直分库，水平分库。垂直分库针对的是数据类型，水平分库针对的是数据大小。水平分库可有效地环节单击和单库的性能瓶颈，突破Io,连接数等硬件资源的限制。

​	水平分库的规则：根据主键hash取模，即id%n(库的实例)，根据余数来确定是哪个表。

结论： 数据量大的时候要分表，并发量大的时候要分库。高并发大数据量时要分库分表。

分库分表的算法：

​	垂直拆分是根据业务来的。没有算法。拆分算法指的就是水平分库分表。

​	1.范围分片：

​		1.时间维度

​		如日志表，订单表，是按照时间来划分的

​		2.地域维度

​		如天气表，是根据省，市行政区来进行划分。

​		3.大小维度

​		常见的事用户表，0~1000w的用户在一张表，1001~2000w在另一张表。

```
	数据库最终划分：冷数据并不放到mysql里，mysql主要用来做关联查询。像日志最后也会放到es里。
```

​		缺点：可能存在热点数据，造成数据倾斜，数据库压力分摊不均匀。

​	2.hash分片：

​		对关键字进行取模，表示为hash(id)%N,得到余数i，根据i的不同，将订单存储到对应编号	的数据库里。		

​		hash分片的缺点：集群的伸缩性支持上存在问题，节点增加和减少时会出现重新分配的情况。

​		改进：使用一致性hash算法。可以有效地支持集群的动态伸缩。

​	分表的缺点：给查询带来了苦难。连表查询，等都会有问题。	

​	3.查表分片

​		通过数据库查表，确定数据的分片位置。全靠人为来分配。查询前先查询表，了解数据在哪个分片里。
如何处理大分页？

​	利用主键，主键连续的时候直接利用主键查询，不连续的时候，先查询出主键。然后做连表查询。

示例：	

1.利用连续主键：	

​	select * from  t_test where id>100000 limit 100

2.先抽取主键，然后连表查询：

​	select * from t_test t1 join (select id from t_test where name="xxx" limit 100) t2 on t1.id=t2.id

具体可以进行实验，来确定最终采用哪种sql语句

读多写少和读少写多怎么处理

写多读少

1.大学食堂系统，滴滴打车，轨迹信息不断的上传，却很少查询。

​	数据库写入慢是因为有事务机制，因此如果信息不是很重要，数据量又很大，可以使用NoSql,传统数据使用Mysql,高价值数据使用TokuDb,因为它支持事务。TokuDb的写入速度是innodb的9~20倍

2.写多读多

​	mysql的innodb无法承载这种场景，应该使用Nosql。常见的场景就是微信,qq的聊天，离线留言功能,比如redis。这就要做到高性能高可用，以及数据结构的选型。

3.数据库集群

​	缺点：读写速度均低于单节点实例，无论是mycat还是shardingJDBC都采用了代理模式，有额外的代码消耗。

​	优点：可以存放更多的数据。支持更大并发量的访问

注意，insert,update,delete如果没有索引时都会锁住整张表。因此多表事务很容易引起mysql崩溃。

mysql锁：

​	查看事务里锁的语句：

​		select * from performance_schema.data_locks

​	关键参数是LOCK_TYPE,LOCK_DATA,LOCK_MODE,LOCK_STATUS;

逻辑删除还是物理删除：

​	物理删除里，要想恢复数据是有代价的。删除后要想恢复，难度也很大。需要自己查看binlog语句，并剔除删除语句。然后执行binlog。或者给数据库一个延时同步节点。

​	物理删除还会导致主键不连续，使得分页查询缓慢，比如如果我们想分页取得20条数据，但我们又删除了，那么就无法取得20条数据了。因此对于并发量大的表，应该采用逻辑删除，添加一个逻辑删除字段。这样还便于恢复。

​		select ... from ... where id>1000 and id <= 1020;

UUID的缺点：

​	1.数据写入的随机性很大，不是顺序写入，给IO带来很大负担。

​	2。浪费存储空间，uuid占用了16个字节。

​	在分布式环境下，可以使用mycat来生成全局连续的唯一id。

实现商品秒杀：

​	注意：当出现针对数据库里某一行记录进行修改的业务时，就要设置锁，乐观锁可以抗住高并发，因此应该对该数据库表设置乐观锁。

​	redis使用：

​	在redis里使用乐观锁，应该采用lua脚本，来保证原子性。

缓存：

​	分为redis的缓存和java程序端的缓存。即springcache；

mysql参数优化：

​	1.最大连接数： max_connections;

​	2.back_log：存放执行请求的堆栈大小，当并发连接达到了最大值，剩下的就会放在这个堆栈里

​	3.并发线程数：innodb_thread_concurrency，推荐和cpu核数一致

​	4.修改连接超时时间： wait-timeout

​	5.innodb_buffer_pool_size:缓存大小，可以设置成主机内存的70~80%；

慢查询日志，以及explain的使用


