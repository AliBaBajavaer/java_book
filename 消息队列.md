```java
  <!--  rabbitmq的maven依赖-->
    <dependency>
      <groupId>com.rabbitmq</groupId>
      <artifactId>amqp-client</artifactId>
      <version>5.7.1</version>
    </dependency>
```

rabbitmq的maven依赖

在docker中启动rabbitmq:

```
docker run --name some-rabbitmq -p 5672:5672 -p 15672:15672 -d rabbitmq:3.12-management
```

外部访问端口为15672，消息队列一端进，一端出，进对应15672，出对应的是5672

怎么在java里发送消息：

#### 	1.在rabbitmq里新建主机，队列

#### 	2.添加maven依赖

​	

```xml
 <!--AMQP依赖，包含RabbitMQ-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
```

#### 在yml里配置rabbitmq

```yml
spring:
  rabbitmq:
    host: 192.168.168.134
    port: 5672
    virtual-host: /
    username: guest
    password: guest
```

#### 	生产者：使用api操作rabbitmq

```java
 @Autowired
    public RabbitTemplate rabbitTemplate;
    @Test
    public void testSend(){
        String queueName="hello.queue1";
        String message="hello amp";
        rabbitTemplate.convertAndSend(queueName,message);
    }
```

​	发送成功

​	![image-20240205103122274](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240205103122274.png)

### 接收消息：消费者

#### 	在另一个服务yml中配置rabbitmq的信息，与consumer相同	

```yml
spring:
  rabbitmq:
    host: 192.168.168.134
    port: 5672
    virtual-host: /
    username: guest
    password: guest
```

#### 	配置bean ,在方法上加上@RabbitListener(queues="hello.queue1 队列名字"),将类配置为component

```java
@Component
@Slf4j
public class MyRabbitMqListener {

    @RabbitListener(queues = {"hello.queue1","hello.queue2"})
    public void  listenSimpleQueue(String msg)      //msg就是消息，spring 自己传递
    {
        System.out.println("收到了消息: ["+msg+"]");
    }
}
```

#### 启动消费者所在的springboot工程：

​	![image-20240205104255581](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240205104255581.png)

#### 发送消息，接收成功：

​	![image-20240205104509371](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240205104509371.png)

**发消息使用：RabbitTemplate(rabbittemplate.convertAndSend(queueName,message)) ,接收消息使用：@RabbitListener(queues={"",""})**

用多个消费者接收同一个消息队列的消息：

​	为了加快消息处理，可以配置多个消费者来消费消息队列，并且能者多劳，但默认情况下消费者会平均的投递消息给消费者。为了改变：需要在yml中添加配置信息

```java
  @RabbitListener(queues = "worker.queue")
    public void listenWorkerQueue1(String msg){
        System.out.println(" 消费者1worker.queue的消息：["+msg+"]");
    }

    @RabbitListener(queues = "worker.queue")
    public void listenWokerQueue2(String msg)
    {
        System.out.println(" 消费者2worker.queue的消息：["+msg+"]");
    }
 

```

消费者发送50条消息	

```java
 
 @Test
    public void testWorkQueue() throws InterruptedException {
        String queueName="worker.queue";
        for (int i = 0; i < 50; i++) {
            String message="这是第："+i+"条消息";
            rabbitTemplate.convertAndSend(queueName,message);
            Thread.sleep(20);
        }
    }
```

### 消息推送限制：

​	在yml中添加prefetch：1配置，表示，消费者只有消费完了才能继续接收消息，防止消息堆积

​	默认情况下，消息队列会以轮询的方式（不考虑消费者的工作效率）依次将消息投递给绑定在队列上的每一个消费者，但并没有考虑消费者有没有处理完消息，会出现消息堆积，降低消息的处理速度；

```
    srping: 
    	rabbitmq: 
    		listener:
      			simple:
        			prefetch: 1
```



## 交换机

### fanout交换机

​	实际开发中，生产者会把消息发给交换机，而不是直接发送到队列，而且一个消息需要多个固定的消费者消费，如果直接发送给消息队列，那么这条消息只能被一个未知消费者消费，因此实际开发中，需要把消息转发给交换机，交换机转发给消息队列

​	fanout广播发送：使用fanout类型的交换机时，交换机会将消息广播给所有与他绑定的消息队列,就是说每个消息会给所有人都发一份。



1.新建消息队列

2.添加交换机，将交换机的类型设定为fanout,

<img src="C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240205120609909.png" alt="image-20240205120609909" style="zoom:50%;" />

3.在交换机里绑定消息队列

​						![image-20240205120658142](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240205120658142.png)			

4.java层面：

​	用多个rabbitmqlistener绑定不同的消息队列；(消费者模块)

```java
  @RabbitListener(queues = "fanout.queue1")
    public  void listenFanoutQueue1(String msg) {
        System.out.println(" 消费者1 fanout.queue1的消息：.....["+msg+"]");
    }
    @RabbitListener(queues = "fanout.queue2")
    public  void listenFanoutQueue2(String msg) {
        System.out.println(" 消费者1 fanout.queue2的消息：.....["+msg+"]");
    }
```

​	生产者模块：用rabbitmqtemplate.convert()发送消息，第一个参数是交换机的名字，第二个参数是消息队列的key（如果要广播，就写null）,第三个是要转发的消息

```java
 @Test
    public void testFanout(){
        String exchangeName="hmall.fanout";
        String msg="hello,everyone!";
        rabbitTemplate.convertAndSend(exchangeName,null,msg);
    }
```

### direct交换机	

​	交换机：生产者只与交换机关联，消息通过key与特定的消息队列关联，消费者只和消息队列关联，通过RabbitMqListener(queues="")关联，交换机与消息队列,key间的关系在rabbitmq自己指定，在mq上以key为键建立hashmap,交换机将消息转发给key对应的消息队列。绑定只能一个key一个key的绑定

​	1.在交换机上绑定

​	![image-20240205135118264](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240205135118264.png)

消费者接收消息

```java
  @RabbitListener(queues = "direct.queue1")
    public  void listenDirectQueue1(String msg)
    {
        System.out.println(" 消费者 direct.queue1的消息：.....["+msg+"]");
    }

    @RabbitListener(queues = "direct.queue2")
    public  void listenDirectQueue2(String msg)
    {
        System.out.println(" 消费者 direct.queue2的消息：.....["+msg+"]");
    }
```

生产者发送消息，在convertAndSend()里第二个参数指定key的名字

```java
  @Test
    public void hsfdgs()
        {
            String exchangeName="hmall.direct";
            String msg="hello everyone";

            rabbitTemplate.convertAndSend(exchangeName,"red",msg);
        }
```

### topic交换机

​	使用通配符，将一个消息队列与多个类型的消息绑定，不知道选哪个类型的交换机，就用topic

​	1.设置交换机类型，将交换机与消息队列绑定

<img src="C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240205140806559.png" alt="image-20240205140806559" style="zoom:50%;" />

​		2.生产者发送消息

```java
     @Test
    public void testTopicQueue(){
        String exchangeName="hmall.topic";
        String msg="hello ..........";
        rabbitTemplate.convertAndSend("hmall.topic","#.news",msg);
        }
```

​		3.消费者监听消息

```java
 @RabbitListener(queues = "topic.queue1")
    public  void listenTopicQueue1(String msg)
    {
        System.out.println(" 消费者 topic.queue1的消息：.....["+msg+"]");
    }

    @RabbitListener(queues = "topic.queue2")
    public  void listenTopicQueue2(String msg)
    {
        System.out.println(" 消费者 topic.queue2的消息：.....["+msg+"]");
    }
```



## 在java里声明交换机，绑定消息队列 

​	手动创建交换机，消息队列容易出错，实际上，在网站创建交换机，消息队列是将参数封装成请求发给服务器，那其实在java代码里创建是一样的。

### 使用@Component,@Bean创建

交换机：对应FanoutExchange,DirectExchange,TopicExchange 三个类，使用工厂对象 ExchangeBuilder.fanoutExchange().build()创建

消息队列：对应Queue类，使用QueueBuilder.durable("").build();创建，durable里需要传递消息队列的名字；

绑定关系：对应Binding类，使用BindingBuilder.bind().to();创建

​		但对于DirectExchange,TopicExchange类，则要在to方法后边添加with方法，传入key的名称。

​		一个Queue至少对应一个Binding对象

注意，这些配置写在consumer代码里

```java
@Configuration
public class ExchangeConfiguration {
    /**
     * 1.@Bean
     * 作用：
     * • 用于把当前方法的返回值作为bean对象存入spring的容器中
     * – 属性：
     * • name：用于指定bean的id。当不写时，bean的id默认为当前方法的名称
     * – 细节：
     * • 当我们使用注解配置方法时，如果方法有参数，spring框架会到bean容器
     * 中查找有没有可用的bean对象，查找的方式和Autowired注解的方式是一
     * 样的、
     */

    /**
     * 创建交换机
     * @return
     */
    @Bean
    public FanoutExchange fanoutExchange()
        {
            return ExchangeBuilder.fanoutExchange("M.fanout1").build();
            //交换机重要的是名字和类型，
        }
    /**
     * 创建消息队列
     * 队列最重要的也是名字
     */
    @Bean
    public Queue fanoutQueue1()
        {
            return QueueBuilder.durable("M.fanout.queue1").build();
        }
    /**
     * 将消息队列与交换机绑定
      */
    @Bean
    public Binding fanoutBinding(@Autowired @Qualifier("fanoutQueue1") Queue fanoutQueue1, FanoutExchange fanoutExchange)
    {
        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);
    }
    /**
     * 每一个queue都对应一个Bind,这里Bind,Queue都应该按名称注入，
     可以在@Bean后边配置名称。然后Autowired,Qualifier按名称注入就行
     * @return
     */
    @Bean
    public Queue fanoutQueue2(){
       return QueueBuilder.durable("M.fanout.queue2").build();
    }
    @Bean
    public Binding fanoutBinding1(@Autowired @Qualifier("fanoutQueue2") Queue fanoutQueue2,FanoutExchange fanoutExchange)
    {
        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);
    }


}
```

### 使用注解创建

```java
   @RabbitListener(bindings = @QueueBinding(
            value = @Queue(name = "N.direct.queue1"), //队列的名字，不存在就创建
            exchange = @Exchange(name ="N.direct" ,type= ExchangeTypes.DIRECT), //交换机，不存在就创建
            key= {"red","blue"}										//routingKey的类型
    ))
    public void listenFanoutQueue3(String msg)
    {
        System.out.println(" 消费者 topic.queue2的消息：.....["+msg+"]");
    }

//也可以创建多个绑定
 /***
     * 使用注解配置多个消息队列
     */
     @RabbitListener(
          bindings= {@QueueBinding(  //这里指定成了lazyqueue，便于持久化消息
                  value = @Queue(name="cloud.direct.queue1"
                  ,durable = "true",
                  arguments = @Argument(name="x-queue-mode",value = "lazy")),
                  exchange = @Exchange(name = "cloudLearnDirect",type = ExchangeTypes.DIRECT),
                  key = {"RED","BLUE"}
          ),
          @QueueBinding( value = @Queue(name="cloud.direct.queue22"),
                  exchange = @Exchange(name = "cloudLearnDirect",type = ExchangeTypes.DIRECT),
                  key = {"REDD","BLUEE"})}
    )
    public void listenFanoutQueue3(String msg){
        System.out.println(" 消费者 topic.queue2的消息：.....["+msg+"]");
    }
```



## 消息转换器

​	发送的消息如果是对象类型的，需要配置json序列化方式，代码如下,注意，两边都要配。

```java
@SpringBootApplication
public class ConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }
    /**
     * 序列化
     * @return
     */
    @Bean
    public MessageConverter jacksonMessageConvertor(){
        return new Jackson2JsonMessageConverter();
    }
}
```

​	接收消息方式,直接使用类型装配

```java
 @RabbitListener(queues = "topic.queue2")
    public void testJackSon(Map<String,Object> msg)
    {
        System.out.println(msg);
    }
```

​	当然在主工程里加入jackson依赖

```xml
  <!--Jackson-->
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-xml</artifactId>
        </dependency>
```

## rabbitmq的稳定性保证：

​	消息发送过程中，发送者，消息队列，消费者任何一个地方出问题，消息都会出问题，造成消息丢失。解决办法如下：

​	核心：每一个节点接收请求后，都向发送方发送ack，否则发送方就要重发消息

​		展现：1.消息队列在拿到消息以后，立刻将消息写入磁盘，写入磁盘完成后，将ack发给生产者，这样生产者才				会发送下一条消息，消息队列在发送消息的时候，是从磁盘里拿出消息来发送的。

​			2.消费者只有在消费完消息后，才会给消息队列发送ack，消息队列才会删除消息；

​	缺陷：生产者有可能崩掉，那就没有办法了。本质上生产者这里没有办法持久化，所以消息还是会丢。

### 生产者发送重连

生产者连接mq失败时，可以开启重连机制，，这里并不处理发送失败，而是发送前的连接失败。

```yml
spring:
 rabbitmq:
 	connection-timeout: 1s      连接时长超过1s认为连接失败
    template:
      retry:
        enabled: true			是否允许重试
        initial-interval: 1000ms 初始重试时间1000ms
        multiplier: 1			失败后的重试时间为初始重试时间的倍数
        max-attempts: 3			最大尝试次数
```

### 生产者确认

​	生产者发送消息，确保消息队列确实受到了消息。流程就是消息经过交换机确实放到了消息队列里，因此可能出问题的地方是两个，一是交换机没有收到消息，即发送失败，而是交换机没有绑定消息队列，消息路由失败，因此rabbitmq用两种确认机制来描述这种状况。对于路由失败，是没有办法通过重发来解决的。因此我们只能通过重发来解决发送失败的问题。

​	用于处理publisher与rabbitmq的故障，即接收失败的问题的问题：

​	交换机和消息队列一个内存里，他们两个不存在信息交换失败的情况，生产者确认一共有四种情况：

ReturnsReturn:	消息封装在ReturnCallBack里

​	1.交换机的hashmap为空，没有消息队列绑定到交换机上，消息会投递成功，但路由失败，此时会通过PublishReturn返回路由异常的原因，然后返回ack，告知投递成功，我们可以记录日志，进行排查；spring里面封装了Return信息的类，我们可以在Bean初始化完成后设置这个类。

Publisher Confirm:消息封装在ConfirmCallBack里

​	1.临时消息投递到了mq,入队成功，返回ack，告知投递成功

​	2.持久消息到了mq，入队成功且写入到磁盘（完成持久化），返回ACK

​	3.其他均返回NACK(比如磁盘故障，内存爆满等)

但要注意，两者开启后，性能会变差.

![image-20240205204128426](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240205204128426.png)

spring amqp使用两个方式来处理这两种消息类型，

​	首先在yml文件中配置，支持对这两种消息类型进行处理

```yml
    spring:
    	rabbitmq:
    		publisher-confirm-type: correlated #MQ异步回调的方式返回消息 simple则是阻塞消费者的代码；none#为不开启确认机制。
    		publisher-returns: true
```

![image-20240622165816970](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240622165816970.png)	

```java
@Component
@RequiredArgsConstructor  //该注解会给这个类生成一个包含final对象的构造函数，
public class MqConfig {
    private final RabbitTemplate rabbitTemplate;

    //设置retrunCallBack的格式，用于消息在消息队列里路由失败时，保存失败信息，并返回
    @PostConstruct
    public void init(){
        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {
            @Override
            public void returnedMessage(ReturnedMessage returnedMessage) {
                //returnMessage里已经保存了所有的失败信息了,我们只需要打印出来就行了
                System.err.println("触发return callback");
                System.out.println("exchange:"+ returnedMessage.getExchange());
                System.out.println("routingKey:"+returnedMessage.getRoutingKey());
                System.out.println("message:"+returnedMessage.getMessage());
                System.out.println("replyCode:"+returnedMessage.getReplyCode());
                System.out.println("replyText:"+returnedMessage.getReplyText());
            }
        });
    }
}
```

ConfirmCallBack的确认：每次发消息前来配置,callback也是一个消息，他需要经过spring框架，才能到达生产者这里，因此在spring框架里也会出现异常。所以重写方法里，有一个onFailure，表示spring处理时的异常，onSuccess表示生产者成功拿到了ConfirmCallBack

```java
    @Test
    public void testConfirmCallBack(){
        //设置ConfirmCallBack,他保存在CorrelationData里；
        CorrelationData cd = new CorrelationData(UUID.randomUUID().toString()); //传入的参数是消息的Id;要保证唯一性
        cd.getFuture().addCallback(new ListenableFutureCallback<CorrelationData.Confirm>() {
            //没用，是处理future过程中发生的异常
            @Override
            public void onFailure(Throwable ex) {
                System.err.println("springamqp处理确认结果异常"+ex);
            }
            //future处理成功，拿到callback,判断是否成功
            @Override
            public void onSuccess(CorrelationData.Confirm result) {
                if(result.isAck())
                {
                    System.out.println("收到confirmCallback,ack,消息发送成功");
                }
                else{//发送失败，需要重发消息

                    System.out.println("收到confirmCallback,nack,消息发送失败，原因是"+result.getReason());
                }
            }
        });
        String exchange="cloudLearnTopic";
        String queueName="cloudLearn.queue1";
        String message="hello AliBABA";
        for (int i = 0; i < 100; i++) {
            rabbitTemplate.convertAndSend(exchange,"china.news",message+":  "+i,cd); //发送消息；但应该采用中介模式，采用交换机来发
        }
        for (int i = 0; i < 100; i++) {
            rabbitTemplate.convertAndSend(exchange,"america.news",message+":  "+i,cd); //发送消息；但应该采用中介模式，采用交换机来发
        }
        Thread.sleep(20);

    }

```

​	

ReturnsCallBack:需要RabbitMqTemplate对象需要setReturnsCallback(),这可以使用是实现Aware接口来做，用一个配置类实现ApplicationContextAware接口，实现里面的方法，方法传入的参数就是applicationcontext 里的spring 存放bean的单例池，可以从里面拿出来rabbitmq对象，设置ReturnsCallback对象.

```java
@Configuration
@Slf4j
public class CommonConfig implements ApplicationContextAware {
    /**
     * 把Spring单例池传过来，做增强，添加ReturnCallBack,用来处理某种类型的消息信息
     * @param applicationContext
     * @throws BeansException
     */
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);
        rabbitTemplate.setReturnsCallback(new RabbitTemplate.ReturnsCallback() {
            @Override
            public void returnedMessage(ReturnedMessage returnedMessage) {
                log.info("消息发送失败，应答码{}，原因{}，交换机{}，路由器{}，消息{}",
                        returnedMessage.getReplyCode(),
                        returnedMessage.getReplyText(),
                        returnedMessage.getExchange(),
                        returnedMessage.getRoutingKey(),
                        returnedMessage.getMessage().toString()
                        );
            }
        });
        }
}
```

​	Publish Confirm:需要CorrleationData对象，对象需要一个UUID.randomInt(),CD对象会对ack,nack进行处理，nack当然要重发报文

```java
 /**
     * ConfirmCallback，处理ack,nack情况，
     */
    @Test
    public void testPublisherConfirm() throws InterruptedException {
        CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
        correlationData.getFuture().addCallback(new ListenableFutureCallback<CorrelationData.Confirm>() {
            @Override
            public void onFailure(Throwable ex) {
                log.error("spring处理出错",ex);
            }

            @Override
            public void onSuccess(CorrelationData.Confirm result) {
                if(result.isAck()){
                    log.debug("发送消息成功，收到ack");
                }
                else{
                    log.debug("发送消息失败，原因是：{}",result.getReason());
                    /**
                     * 之后还要重发消息
                     */
                }
            }
        });
        String msg="rabbitmq,and rabbitmq";
        String exchangeName="hmall.topic";
        String key="china1.#";
        //在这里发送消息
        rabbitTemplate.convertAndSend(exchangeName,key,msg,correlationData);

        Thread.sleep(2000);
    }
```

### mq的数据稳定性

#### 数据持久化：

​	需要在代码里的工作：设置消息的类型，交换机的类型，消息队列的类型为持久性或临时性，临时性会清理内存，持久性会写入磁盘，持久性会对性能造成影响。除此之外，publish confirm,returncallback也会对性能产生影响；

​	需要写代码的：spring默认交换机和消息队列是持久化的，写代码时要额外设置消息的持久化类型，其余不变

```java
@Test
    public void testPageOut(){
        //json发送字符串，必须加上双引号
        //数据持久化：配置交换机，消息队列，消息的持久化类型，不同的持久化类型对数据有影响，
        Message message = MessageBuilder.withBody("\"hellohello\"".getBytes(StandardCharsets.UTF_8))//设置消息
                .setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT)//设置消息的持久化模式
                .build();
        for (int i = 0; i < 100000; i++) {
            rabbitTemplate.convertAndSend("hmall.topic","china.#",message);
        }
    }
```

#### lazyQueue

​	通过给消息队列开启lzayQueue的模式，交换机发送来的数据，消息队列会先把消息写入磁盘，用的时候在同一加载，这样可以保证消费者取消息的时候不会发生消息阻塞。给人的感觉是整体慢了一点，但不会出现阻塞（长时间不响应）的情况。

如何开启lazyqueue:

1.控制台创建队列时加入参数

2.配置bean的时候开启lazy模式

3.使用注解配置	

​	开启lazqueue后，数据写入磁盘后，mq才会给生产者发送ack。

控制台开启

![image-20240206120701080](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240206120701080.png)

配置bean的时候加入：

```java
@Bean("M.lazy.queue1")
    public Queue TopicQueue1(){return QueueBuilder.durable().lazy().build();}//build();} 
    @Bean 
    public Binding binding2(@Autowired @Qualifier("M.lazy.queue1") Queue queue,@Autowired @Qualifier("M.direct1") DirectExchange exchange)
    {
        return BindingBuilder.bind(queue).to(exchange).with("www");
    }
```

再RabbitMqListener上使用注解

```java
@RabbitListener(bindings = @QueueBinding(
            value = @Queue(
                    name="lazy.queue1",
                    durable = "true",
                    arguments = @Argument(name= "x-queue-mode",value="lazy")
            ),
            exchange = @Exchange(name ="N.direct" ,type= ExchangeTypes.DIRECT),
            key= {"red","blue"}
                   
            
    ))
    public void listenLazyQueue(String msg){
        System.out.println(msg);
    }
```

![image-20240206120243004](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240206120243004.png)

mq可能的问题：

​	mq接收的消息都保存在内存中，一旦mq宕机，内存中的数据会丢失，或者由于消费者故障或者处理过慢时导致消息挤压，使得mq无法在接收新的消息，而mq会采取清理内存，或者写磁盘的做法，都会导致mq阻塞，无法接收消息。

​	为什么数据迁移会阻塞？mq对底层数据结构增删改查时一定会加锁，否则就是线程不安全的。因此执行时就会阻塞。

## 消费者确认

#### 远程重试：

![image-20240206215646868](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240206215646868.png)

![image-20240206215620781](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240206215620781.png)

消费者的稳定性采用yml配置来解决:选择auto，spring会自动给你配置，配置再监听者的yml里监听

```yml
spring:
	rabbitmq:
		listener:
			simple:
				acknowledge-mode: none || manual || auto 
```



#### 本地重试机制：

​	本地重试机制与远程重试在关系上是各自独立的，不是递进的关系，远程重试会给消息队列带来很大的压力，因此实际都采用本地重试，但重试耗尽后，会将消息丢弃，因此为了保存消息，应该调用RepublishMessageRecover,即重试耗尽后，将消息投递到指定的交换机。但他们两个可以同时开启。这里也是采用了模板方法设计模式。

![image-20240206225731834](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240206225731834.png)

![image-20240206230127377](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240206230127377.png)

```yml
spring:
  rabbitmq:
    host: 192.168.168.134
    port: 5672
    virtual-host: /
    username: guest
    password: guest
    listener:
      simple:
        prefetch: 1
        acknowledge-mode: auto
        retry:
          enabled: true
          initial-interval: 1000ms
          multiplier: 1
          max-attempts: 3
          stateless: false

```

定义接收异常信息的交换机，队列，以及绑定关系，然后定义RepublishMessageRecover，

```java
@Configuration
@ConditionalOnProperty(prefix = "spring.rabbitmq.listener.simple.retry",name="enabled",havingValue = "true")
public class ErrorConfiguration {
    @Bean
    public DirectExchange errorExchange(){
        return ExchangeBuilder.directExchange("error.direct").build();
    }
    @Bean
    public Queue errorQueue()
        {
            return QueueBuilder.durable("error.queue").lazy().build();
        }
        @Bean
    public Binding errorBinding(Queue errorQueue,DirectExchange errorExchange)
            {
                return BindingBuilder.bind(errorQueue).to(errorExchange).with("error");
            }
       @Bean
    public MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate)
       {
           return new RepublishMessageRecoverer(rabbitTemplate,"error.direct","error");
       }
}
```

业务幂等性

​	spring处理完成后，返回ack的时候因为网络原因mq没有及时收到，导致mq认为消息没有成功处理，mq就会重新发送消息，这就会造成一条消息多次消费，这就是有问题的。因此要保证业务的幂等性。为了保证幂等性，往往需要采用数据库作为中间状态，来查询；

​	![image-20240622195153202](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240622195153202.png)

解决办法：在jackson2j里自动生成消息id,再发送消息时会自动生成消息id。

```java
 @Bean
    public MessageConverter jacksonMessageConvertor(){

        Jackson2JsonMessageConverter jackson2JsonMessageConverter = new Jackson2JsonMessageConverter();
        jackson2JsonMessageConverter.setCreateMessageIds(true); //生成消息Id,
        return jackson2JsonMessageConverter;
    }
```

这样配置以后，消息存放在消息体里，Id存放在messagrPropities里，消息体是以字节的方式存储的，应该用字符串来接。

```java
  @RabbitListener(queues = {"cloudLearnTopic.queue2"})
    public void  listenSimpleQueueTopic1(Message message) throws InterruptedException      //msg就是消息，spring 自己传递
    {
        Thread.sleep(100);
        byte[] body = message.getBody(); //消息在消息体里
       // new String(body,"utf-8") 
        java.lang.String s = new java.lang.String(body);//获得消息
        java.lang.String messageId = message.getMessageProperties().getMessageId();//消息的Id
        System.err.println("收到了消息: ["+s);
    }
```

业务逻辑：为了保证幂等性，可以采用乐观锁来保证幂等性。注意，为了保证幂等性，只有数据可以，其他的都不行，因此任何要保证幂等性的业务都要采用数据库。可以采用乐观锁，状态版本来解决。

延迟消息

​	发送者发送消息时指定一个时间，消费者不会立即接收到消息，而是在指定时间之后收到消息；

![image-20240622233349112](C:\Users\19116\AppData\Roaming\Typora\typora-user-images\image-20240622233349112.png)

死信交换机就是一个正常的交换机，用于接收死信，死信交换机要和消息队列绑定
